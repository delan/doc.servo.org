<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits and helpers for bitstream handling functionality"><title>bitstream_io - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bitstream_io" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate bitstream_io</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bitstream_io/index.html">bitstream_<wbr>io</a><span class="version">2.6.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#minimum-compiler-version" title="Minimum Compiler Version">Minimum Compiler Version</a></li><li><a href="#migrating-from-pre-100" title="Migrating From Pre 1.0.0">Migrating From Pre 1.0.0</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>bitstream_<wbr>io</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bitstream_io/lib.rs.html#9-1029">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits and helpers for bitstream handling functionality</p>
<p>Bitstream readers are for reading signed and unsigned integer
values from a stream whose sizes may not be whole bytes.
Bitstream writers are for writing signed and unsigned integer
values to a stream, also potentially un-aligned at a whole byte.</p>
<p>Both big-endian and little-endian streams are supported.</p>
<p>The only requirement for wrapped reader streams is that they must
implement the <code>Read</code> trait, and the only requirement
for writer streams is that they must implement the <code>Write</code> trait.</p>
<p>In addition, reader streams do not consume any more bytes
from the underlying reader than necessary, buffering only a
single partial byte as needed.
Writer streams also write out all whole bytes as they are accumulated.</p>
<p>Readers and writers are also designed to work with integer
types of any possible size.
Many of Rustâ€™s built-in integer types are supported by default.</p>
<h2 id="minimum-compiler-version"><a class="doc-anchor" href="#minimum-compiler-version">Â§</a>Minimum Compiler Version</h2>
<p>Beginning with version 2.4, the minimum compiler version has been
updated to Rust 1.79.</p>
<p>The issue is that reading an excessive number of
bits to a type which is too small to hold them,
or writing an excessive number of bits from too small of a type,
are always errors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, Cursor};
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data = [<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(Cursor::new(<span class="kw-2">&amp;</span>data), BigEndian);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw">_</span>&gt; = r.read(<span class="number">64</span>);  <span class="comment">// reading 64 bits to u32 always fails at runtime
</span><span class="macro">assert!</span>(x.is_err());</code></pre></div>
<p>but those errors will not be caught until the program runs,
which is less than ideal for the common case in which
the number of bits is already known at compile-time.</p>
<p>But starting with Rust 1.79, we can now have read and write methods
which take a constant number of bits and can validate the number of bits
are small enough for the type being read/written at compile-time:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, Cursor};
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data = [<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(Cursor::new(<span class="kw-2">&amp;</span>data), BigEndian);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw">_</span>&gt; = r.read_in::&lt;<span class="number">64</span>, <span class="kw">_</span>&gt;();  <span class="comment">// doesn't compile at all</span></code></pre></div>
<p>Since catching potential bugs at compile-time is preferable
to encountering errors at runtime, this will hopefully be
an improvement in the long run.</p>
<h2 id="migrating-from-pre-100"><a class="doc-anchor" href="#migrating-from-pre-100">Â§</a>Migrating From Pre 1.0.0</h2>
<p>There are now <code>BitRead</code> and <code>BitWrite</code> traits for bitstream
reading and writing (analogous to the standard libraryâ€™s
<code>Read</code> and <code>Write</code> traits) which you will also need to import.
The upside to this approach is that library consumers
can now make functions and methods generic over any sort
of bit reader or bit writer, regardless of the underlying
stream byte source or endianness.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">Â§</a></h2><dl class="item-table reexports"><dt id="reexport.BitRead"><code>pub use read::<a class="trait" href="read/trait.BitRead.html" title="trait bitstream_io::read::BitRead">BitRead</a>;</code></dt><dt id="reexport.BitReader"><code>pub use read::<a class="struct" href="read/struct.BitReader.html" title="struct bitstream_io::read::BitReader">BitReader</a>;</code></dt><dt id="reexport.ByteRead"><code>pub use read::<a class="trait" href="read/trait.ByteRead.html" title="trait bitstream_io::read::ByteRead">ByteRead</a>;</code></dt><dt id="reexport.ByteReader"><code>pub use read::<a class="struct" href="read/struct.ByteReader.html" title="struct bitstream_io::read::ByteReader">ByteReader</a>;</code></dt><dt id="reexport.FromBitStream"><code>pub use read::<a class="trait" href="read/trait.FromBitStream.html" title="trait bitstream_io::read::FromBitStream">FromBitStream</a>;</code></dt><dt id="reexport.FromBitStreamWith"><code>pub use read::<a class="trait" href="read/trait.FromBitStreamWith.html" title="trait bitstream_io::read::FromBitStreamWith">FromBitStreamWith</a>;</code></dt><dt id="reexport.FromByteStream"><code>pub use read::<a class="trait" href="read/trait.FromByteStream.html" title="trait bitstream_io::read::FromByteStream">FromByteStream</a>;</code></dt><dt id="reexport.FromByteStreamWith"><code>pub use read::<a class="trait" href="read/trait.FromByteStreamWith.html" title="trait bitstream_io::read::FromByteStreamWith">FromByteStreamWith</a>;</code></dt><dt id="reexport.HuffmanRead"><code>pub use read::<a class="trait" href="read/trait.HuffmanRead.html" title="trait bitstream_io::read::HuffmanRead">HuffmanRead</a>;</code></dt><dt id="reexport.BitCounter"><code>pub use write::<a class="struct" href="write/struct.BitCounter.html" title="struct bitstream_io::write::BitCounter">BitCounter</a>;</code></dt><dt id="reexport.BitRecorder"><code>pub use write::<a class="struct" href="write/struct.BitRecorder.html" title="struct bitstream_io::write::BitRecorder">BitRecorder</a>;</code></dt><dt id="reexport.BitWrite"><code>pub use write::<a class="trait" href="write/trait.BitWrite.html" title="trait bitstream_io::write::BitWrite">BitWrite</a>;</code></dt><dt id="reexport.BitWriter"><code>pub use write::<a class="struct" href="write/struct.BitWriter.html" title="struct bitstream_io::write::BitWriter">BitWriter</a>;</code></dt><dt id="reexport.ByteWrite"><code>pub use write::<a class="trait" href="write/trait.ByteWrite.html" title="trait bitstream_io::write::ByteWrite">ByteWrite</a>;</code></dt><dt id="reexport.ByteWriter"><code>pub use write::<a class="struct" href="write/struct.ByteWriter.html" title="struct bitstream_io::write::ByteWriter">ByteWriter</a>;</code></dt><dt id="reexport.HuffmanWrite"><code>pub use write::<a class="trait" href="write/trait.HuffmanWrite.html" title="trait bitstream_io::write::HuffmanWrite">HuffmanWrite</a>;</code></dt><dt id="reexport.ToBitStream"><code>pub use write::<a class="trait" href="write/trait.ToBitStream.html" title="trait bitstream_io::write::ToBitStream">ToBitStream</a>;</code></dt><dt id="reexport.ToBitStreamWith"><code>pub use write::<a class="trait" href="write/trait.ToBitStreamWith.html" title="trait bitstream_io::write::ToBitStreamWith">ToBitStreamWith</a>;</code></dt><dt id="reexport.ToByteStream"><code>pub use write::<a class="trait" href="write/trait.ToByteStream.html" title="trait bitstream_io::write::ToByteStream">ToByteStream</a>;</code></dt><dt id="reexport.ToByteStreamWith"><code>pub use write::<a class="trait" href="write/trait.ToByteStreamWith.html" title="trait bitstream_io::write::ToByteStreamWith">ToByteStreamWith</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="huffman/index.html" title="mod bitstream_io::huffman">huffman</a></dt><dd>Traits and implementations for reading or writing Huffman codes
from or to a stream.</dd><dt><a class="mod" href="read/index.html" title="mod bitstream_io::read">read</a></dt><dd>Traits and implementations for reading bits from a stream.</dd><dt><a class="mod" href="write/index.html" title="mod bitstream_io::write">write</a></dt><dd>Traits and implementations for writing bits to a stream.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.define_numeric.html" title="macro bitstream_io::define_numeric">define_<wbr>numeric</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="macro" href="macro.define_primitive_numeric.html" title="macro bitstream_io::define_primitive_numeric">define_<wbr>primitive_<wbr>numeric</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="macro" href="macro.define_signed_numeric.html" title="macro bitstream_io::define_signed_numeric">define_<wbr>signed_<wbr>numeric</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BigEndian.html" title="struct bitstream_io::BigEndian">BigEndian</a></dt><dd>Big-endian, or most significant bits first</dd><dt><a class="struct" href="struct.BitQueue.html" title="struct bitstream_io::BitQueue">BitQueue</a></dt><dd>A queue for efficiently pushing bits onto a value
and popping them off a value.</dd><dt><a class="struct" href="struct.LittleEndian.html" title="struct bitstream_io::LittleEndian">Little<wbr>Endian</a></dt><dd>Little-endian, or least significant bits first</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Endianness.html" title="trait bitstream_io::Endianness">Endianness</a></dt><dd>A streamâ€™s endianness, or byte order, for determining
how bits should be read.</dd><dt><a class="trait" href="trait.Numeric.html" title="trait bitstream_io::Numeric">Numeric</a></dt><dd>This trait extends many common integer types (both unsigned and signed)
with a few trivial methods so that they can be used
with the bitstream handling traits.</dd><dt><a class="trait" href="trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a></dt><dd>A trait intended for simple fixed-length primitives (such as ints and floats)
which allows them to be read and written to streams of
different endiannesses verbatim.</dd><dt><a class="trait" href="trait.SignedNumeric.html" title="trait bitstream_io::SignedNumeric">Signed<wbr>Numeric</a></dt><dd>This trait extends many common signed integer types
so that they can be used with the bitstream handling traits.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.BE.html" title="type bitstream_io::BE">BE</a></dt><dd>Big-endian, or most significant bits first</dd><dt><a class="type" href="type.LE.html" title="type bitstream_io::LE">LE</a></dt><dd>Little-endian, or least significant bits first</dd></dl></section></div></main></body></html>