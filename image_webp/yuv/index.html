<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Utilities for doing the YUV -&#62; RGB conversion The images are encoded in the Yâ€™CbCr format as detailed here: https://en.wikipedia.org/wiki/YCbCr so need to be converted to RGB to be displayed To do the YUV -&#62; RGB conversion we need to first decide how to map the yuv values to the pixels The y buffer is the same size as the pixel buffer so that maps 1-1 but the u and v buffers are half the size of the pixel buffer so we need to scale it up The simple way to upscale is just to take each u/v value and associate it with the 4 pixels around it e.g. for a 4x4 image:"><title>image_webp::yuv - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="image_webp" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module yuv</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../image_webp/index.html">image_<wbr>webp</a><span class="version">0.2.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module yuv</a></h2><h3><a href="#functions">Module Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate image_<wbr>webp</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">image_webp</a></div><h1>Module <span>yuv</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/image_webp/yuv.rs.html#1-452">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Utilities for doing the YUV -&gt; RGB conversion
The images are encoded in the Yâ€™CbCr format as detailed here: <a href="https://en.wikipedia.org/wiki/YCbCr">https://en.wikipedia.org/wiki/YCbCr</a>
so need to be converted to RGB to be displayed
To do the YUV -&gt; RGB conversion we need to first decide how to map the yuv values to the pixels
The y buffer is the same size as the pixel buffer so that maps 1-1 but the
u and v buffers are half the size of the pixel buffer so we need to scale it up
The simple way to upscale is just to take each u/v value and associate it with the 4
pixels around it e.g. for a 4x4 image:</p>
<p>||||||
|yyyy|
|yyyy|
|yyyy|
|yyyy|
||||||</p>
<p>|||||||
|uu|vv|
|uu|vv|
|||||||</p>
<p>Then each of the 2x2 pixels would match the u/v from the same quadrant</p>
<p>However fancy upsampling is the default for libwebp which does a little more work to make the values smoother
It interpolates u and v so that for e.g. the pixel 1 down and 1 from the left the u value
would be (9<em>u0 + 3</em>u1 + 3<em>u2 + u3 + 8) / 16 and similar for the other pixels
The edges are mirrored, so for the pixel 1 down and 0 from the left it uses (9</em>u0 + 3<em>u2 + 3</em>u0 + u2 + 8) / 16</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.clip.html" title="fn image_webp::yuv::clip">clip</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>This function has been rewritten to encourage auto-vectorization.</dd><dt><a class="fn" href="fn.fill_rgb_buffer_fancy.html" title="fn image_webp::yuv::fill_rgb_buffer_fancy">fill_<wbr>rgb_<wbr>buffer_<wbr>fancy</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Fills an rgb buffer with the image from the yuv buffers
Size of the buffer is assumed to be correct
BPP is short for bytes per pixel, allows both rgb and rgba to be decoded</dd><dt><a class="fn" href="fn.fill_rgb_buffer_simple.html" title="fn image_webp::yuv::fill_rgb_buffer_simple">fill_<wbr>rgb_<wbr>buffer_<wbr>simple</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Simple conversion, not currently used but could add a config to allow for using the simple</dd><dt><a class="fn" href="fn.fill_rgba_row_simple.html" title="fn image_webp::yuv::fill_rgba_row_simple">fill_<wbr>rgba_<wbr>row_<wbr>simple</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="fn" href="fn.fill_row_fancy_with_1_uv_row.html" title="fn image_webp::yuv::fill_row_fancy_with_1_uv_row">fill_<wbr>row_<wbr>fancy_<wbr>with_<wbr>1_<wbr>uv_<wbr>row</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="fn" href="fn.fill_row_fancy_with_2_uv_rows.html" title="fn image_webp::yuv::fill_row_fancy_with_2_uv_rows">fill_<wbr>row_<wbr>fancy_<wbr>with_<wbr>2_<wbr>uv_<wbr>rows</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Fills a row with the fancy interpolation as detailed</dd><dt><a class="fn" href="fn.get_fancy_chroma_value.html" title="fn image_webp::yuv::get_fancy_chroma_value">get_<wbr>fancy_<wbr>chroma_<wbr>value</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="fn" href="fn.mulhi.html" title="fn image_webp::yuv::mulhi">mulhi</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd><code>_mm_mulhi_epu16</code> emulation</dd><dt><a class="fn" href="fn.set_pixel.html" title="fn image_webp::yuv::set_pixel">set_<wbr>pixel</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="fn" href="fn.yuv_to_b.html" title="fn image_webp::yuv::yuv_to_b">yuv_<wbr>to_<wbr>b</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="fn" href="fn.yuv_to_g.html" title="fn image_webp::yuv::yuv_to_g">yuv_<wbr>to_<wbr>g</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="fn" href="fn.yuv_to_r.html" title="fn image_webp::yuv::yuv_to_r">yuv_<wbr>to_<wbr>r</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl></section></div></main></body></html>