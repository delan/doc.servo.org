<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="In graphics code itâ€™s very common to pass `width` and `height` along with a `Vec` of pixels, all as separate arguments. This is tedious, and can lead to errors."><title>imgref - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="imgref" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate imgref</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../imgref/index.html">imgref</a><span class="version">1.12.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>imgref</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/imgref/lib.rs.html#1-972">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>In graphics code itâ€™s very common to pass <code>width</code> and <code>height</code> along with a <code>Vec</code> of pixels,
all as separate arguments. This is tedious, and can lead to errors.</p>
<p>This crate is a simple struct that adds dimensions to the underlying buffer. This makes it easier to correctly keep track
of the image size and allows passing images with just one function argument instead three or four.</p>
<p>Additionally, it has a concept of a <code>stride</code>, which allows defining sub-regions of images without copying,
as well as handling padding (e.g. buffers for video frames may require to be a multiple of 8, regardless of logical image size).</p>
<p>For convenience, there are iterators over rows or all pixels of a (sub)image and
pixel-based indexing directly with <code>img[(x,y)]</code> (where <code>x</code>/<code>y</code> can be <code>u32</code> as well as <code>usize</code>).</p>
<p><code>Img&lt;Container&gt;</code> type has aliases for common uses:</p>
<ul>
<li>Owned: <code>ImgVec&lt;T&gt;</code> â†’ <code>Img&lt;Vec&lt;T&gt;&gt;</code>  (use it in <code>struct</code>s and return types)</li>
<li>Reference: <code>ImgRef&lt;T&gt;</code> â†’ <code>Img&lt;&amp;[T]&gt;</code> (use it in function arguments)</li>
<li>Mutable reference: <code>ImgRefMut&lt;T&gt;</code> â†’ <code>Img&lt;&amp;mut [T]&gt;</code></li>
</ul>
<p>It is assumed that the container is <a href="https://crates.io/crates/rgb/">one element per pixel</a>, e.g. <code>Vec&lt;RGBA&gt;</code>,
and <em>not</em> a <code>Vec&lt;u8&gt;</code> where 4 <code>u8</code> elements are interpreted as one pixel.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>imgref::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>img = Img::new(<span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">1000</span>], <span class="number">50</span>, <span class="number">20</span>); <span class="comment">// 1000 pixels of a 50Ã—20 image

    </span><span class="kw">let </span>new_image = some_image_processing_function(img.as_ref()); <span class="comment">// Use imgvec.as_ref() instead of &amp;imgvec for better efficiency

    </span><span class="macro">println!</span>(<span class="string">"New size is {}Ã—{}"</span>, new_image.width(), new_image.height());
    <span class="macro">println!</span>(<span class="string">"And the top left pixel is {:?}"</span>, new_image[(<span class="number">0u32</span>,<span class="number">0u32</span>)]);

    <span class="kw">let </span>first_row_slice = <span class="kw-2">&amp;</span>new_image[<span class="number">0</span>];

    <span class="kw">for </span>row <span class="kw">in </span>new_image.rows() {
        <span class="comment">// â€¦
    </span>}
    <span class="kw">for </span>px <span class="kw">in </span>new_image.pixels() {
        <span class="comment">// â€¦
    </span>}

    <span class="comment">// slice (x, y, width, height) by reference - no copy!
    </span><span class="kw">let </span>fragment = img.sub_image(<span class="number">5</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">15</span>);

    <span class="comment">//
    </span><span class="kw">let </span>(vec, width, height) = fragment.to_contiguous_buf();
}</code></pre></div></div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="iter/index.html" title="mod imgref::iter">iter</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="ops/index.html" title="mod imgref::ops">ops</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="traits/index.html" title="mod imgref::traits">traits</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Img.html" title="struct imgref::Img">Img</a></dt><dd>Basic struct used for both owned (alias <code>ImgVec</code>) and borrowed (alias <code>ImgRef</code>) image fragments.</dd><dt><a class="struct" href="struct.PixelsIter.html" title="struct imgref::PixelsIter">Pixels<wbr>Iter</a></dt><dd>Iterates over pixels in the (sub)image. Call <code>Img.pixels()</code> to create it.</dd><dt><a class="struct" href="struct.PixelsIterMut.html" title="struct imgref::PixelsIterMut">Pixels<wbr>Iter<wbr>Mut</a></dt><dd>Iterates over pixels in the (sub)image. Call <code>Img.pixels_mut()</code> to create it.</dd><dt><a class="struct" href="struct.PixelsRefIter.html" title="struct imgref::PixelsRefIter">Pixels<wbr>RefIter</a></dt><dd>Iterates over pixels in the (sub)image. Call <code>Img.pixels_ref()</code> to create it.</dd><dt><a class="struct" href="struct.RowsIter.html" title="struct imgref::RowsIter">Rows<wbr>Iter</a></dt><dd>Rows of the image. Call <code>Img.rows()</code> to create it.</dd><dt><a class="struct" href="struct.RowsIterMut.html" title="struct imgref::RowsIterMut">Rows<wbr>Iter<wbr>Mut</a></dt><dd>Rows of the image. Call <code>Img.rows_mut()</code> to create it.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ImgExt.html" title="trait imgref::ImgExt">ImgExt</a></dt><dd>Additional methods that depend on buffer size</dd><dt><a class="trait" href="trait.ImgExtMut.html" title="trait imgref::ImgExtMut">ImgExt<wbr>Mut</a></dt><dd>Additional methods that depend on buffer size</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.sub_image.html" title="fn imgref::sub_image">sub_<wbr>image</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.ImgRef.html" title="type imgref::ImgRef">ImgRef</a></dt><dd>Reference to pixels inside another image.
Pass this structure by value (i.e. <code>ImgRef</code>, not <code>&amp;ImgRef</code>).</dd><dt><a class="type" href="type.ImgRefMut.html" title="type imgref::ImgRefMut">ImgRef<wbr>Mut</a></dt><dd>Same as <code>ImgRef</code>, but mutable
Pass this structure by value (i.e. <code>ImgRef</code>, not <code>&amp;ImgRef</code>).</dd><dt><a class="type" href="type.ImgVec.html" title="type imgref::ImgVec">ImgVec</a></dt><dd>Image owning its pixels.</dd></dl><script type="text/json" id="notable-traits-data">{"RowsIter<'buf, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.RowsIter.html\" title=\"struct imgref::RowsIter\">RowsIter</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, T: 'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.RowsIter.html\" title=\"struct imgref::RowsIter\">RowsIter</a>&lt;'a, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.0/core/primitive.slice.html\">[T]</a>;</div>"}</script></section></div></main></body></html>