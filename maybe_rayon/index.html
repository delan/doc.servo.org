<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `maybe_rayon` crate."><title>maybe_rayon - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="maybe_rayon" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate maybe_rayon</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../maybe_rayon/index.html">maybe_<wbr>rayon</a><span class="version">0.1.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>maybe_<wbr>rayon</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/maybe_rayon/lib.rs.html#1-144">Source</a> </span></div><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="array/index.html" title="mod maybe_rayon::array">array</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/std/primitive.array.html" title="primitive array">arrays</a> (<code>[T; N]</code>)</dd><dt><a class="mod" href="collections/index.html" title="mod maybe_rayon::collections">collections</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/std/collections/index.html" title="mod std::collections">standard collections</a></dd><dt><a class="mod" href="iter/index.html" title="mod maybe_rayon::iter">iter</a></dt><dd>Traits for writing parallel programs using an iterator-style interface</dd><dt><a class="mod" href="option/index.html" title="mod maybe_rayon::option">option</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/core/option/index.html" title="mod core::option">options</a></dd><dt><a class="mod" href="prelude/index.html" title="mod maybe_rayon::prelude">prelude</a></dt><dd>The rayon prelude imports the various <code>ParallelIterator</code> traits.
The intention is that one can include <code>use rayon::prelude::*</code> and
have easy access to the various traits and methods you will need.</dd><dt><a class="mod" href="range/index.html" title="mod maybe_rayon::range">range</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">ranges</a>,
the type for values created by <code>a..b</code> expressions</dd><dt><a class="mod" href="range_inclusive/index.html" title="mod maybe_rayon::range_inclusive">range_<wbr>inclusive</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">inclusive ranges</a>,
the type for values created by <code>a..=b</code> expressions</dd><dt><a class="mod" href="result/index.html" title="mod maybe_rayon::result">result</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/core/result/index.html" title="mod core::result">results</a></dd><dt><a class="mod" href="slice/index.html" title="mod maybe_rayon::slice">slice</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/alloc/slice/index.html" title="mod alloc::slice">slices</a></dd><dt><a class="mod" href="str/index.html" title="mod maybe_rayon::str">str</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/alloc/str/index.html" title="mod alloc::str">strings</a></dd><dt><a class="mod" href="string/index.html" title="mod maybe_rayon::string">string</a></dt><dd>This module contains the parallel iterator types for owned strings
(<code>String</code>). You will rarely need to interact with it directly
unless you have need to name one of the iterator types.</dd><dt><a class="mod" href="vec/index.html" title="mod maybe_rayon::vec">vec</a></dt><dd>Parallel iterator types for <a href="https://doc.rust-lang.org/1.91.0/alloc/vec/index.html" title="mod alloc::vec">vectors</a> (<code>Vec&lt;T&gt;</code>)</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BroadcastContext.html" title="struct maybe_rayon::BroadcastContext">Broadcast<wbr>Context</a></dt><dd>Provides context to a closure called by <code>broadcast</code>.</dd><dt><a class="struct" href="struct.FnContext.html" title="struct maybe_rayon::FnContext">FnContext</a></dt><dd>Provides the calling context to a closure called by <code>join_context</code>.</dd><dt><a class="struct" href="struct.Scope.html" title="struct maybe_rayon::Scope">Scope</a></dt><dd>Represents a fork-join scope which can be used to spawn any number of tasks.
See <a href="fn.scope.html" title="fn maybe_rayon::scope"><code>scope()</code></a> for more information.</dd><dt><a class="struct" href="struct.ScopeFifo.html" title="struct maybe_rayon::ScopeFifo">Scope<wbr>Fifo</a></dt><dd>Represents a fork-join scope which can be used to spawn any number of tasks.
Those spawned from the same thread are prioritized in relative FIFO order.
See <a href="fn.scope_fifo.html" title="fn maybe_rayon::scope_fifo"><code>scope_fifo()</code></a> for more information.</dd><dt><a class="struct" href="struct.ThreadBuilder.html" title="struct maybe_rayon::ThreadBuilder">Thread<wbr>Builder</a></dt><dd>Thread builder used for customization via <a href="struct.ThreadPoolBuilder.html#method.spawn_handler" title="method maybe_rayon::ThreadPoolBuilder::spawn_handler"><code>ThreadPoolBuilder::spawn_handler()</code></a>.</dd><dt><a class="struct" href="struct.ThreadPool.html" title="struct maybe_rayon::ThreadPool">Thread<wbr>Pool</a></dt><dd>Represents a user-created <a href="https://en.wikipedia.org/wiki/Thread_pool">thread pool</a>.</dd><dt><a class="struct" href="struct.ThreadPoolBuildError.html" title="struct maybe_rayon::ThreadPoolBuildError">Thread<wbr>Pool<wbr>Build<wbr>Error</a></dt><dd>Error when initializing a thread pool.</dd><dt><a class="struct" href="struct.ThreadPoolBuilder.html" title="struct maybe_rayon::ThreadPoolBuilder">Thread<wbr>Pool<wbr>Builder</a></dt><dd>Used to create a new <a href="struct.ThreadPool.html" title="struct maybe_rayon::ThreadPool"><code>ThreadPool</code></a> or to configure the global rayon thread pool.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Yield.html" title="enum maybe_rayon::Yield">Yield</a></dt><dd>Result of <a href="fn.yield_now.html" title="fn maybe_rayon::yield_now"><code>yield_now()</code></a> or <a href="fn.yield_local.html" title="fn maybe_rayon::yield_local"><code>yield_local()</code></a>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.broadcast.html" title="fn maybe_rayon::broadcast">broadcast</a></dt><dd>Executes <code>op</code> within every thread in the current thread pool. If this is
called from a non-Rayon thread, it will execute in the global thread pool.
Any attempts to use <code>join</code>, <code>scope</code>, or parallel iterators will then operate
within that thread pool. When the call has completed on each thread, returns
a vector containing all of their return values.</dd><dt><a class="fn" href="fn.current_num_threads.html" title="fn maybe_rayon::current_num_threads">current_<wbr>num_<wbr>threads</a></dt><dd>Returns the number of threads in the current registry. If this
code is executing within a Rayon thread pool, then this will be
the number of threads for the thread pool of the current
thread. Otherwise, it will be the number of threads for the global
thread pool.</dd><dt><a class="fn" href="fn.current_thread_index.html" title="fn maybe_rayon::current_thread_index">current_<wbr>thread_<wbr>index</a></dt><dd>If called from a Rayon worker thread, returns the index of that
thread within its current pool; if not called from a Rayon thread,
returns <code>None</code>.</dd><dt><a class="fn" href="fn.in_place_scope.html" title="fn maybe_rayon::in_place_scope">in_<wbr>place_<wbr>scope</a></dt><dd>Creates a “fork-join” scope <code>s</code> and invokes the closure with a
reference to <code>s</code>. This closure can then spawn asynchronous tasks
into <code>s</code>. Those tasks may run asynchronously with respect to the
closure; they may themselves spawn additional tasks into <code>s</code>. When
the closure returns, it will block until all tasks that have been
spawned into <code>s</code> complete.</dd><dt><a class="fn" href="fn.in_place_scope_fifo.html" title="fn maybe_rayon::in_place_scope_fifo">in_<wbr>place_<wbr>scope_<wbr>fifo</a></dt><dd>Creates a “fork-join” scope <code>s</code> with FIFO order, and invokes the
closure with a reference to <code>s</code>. This closure can then spawn
asynchronous tasks into <code>s</code>. Those tasks may run asynchronously with
respect to the closure; they may themselves spawn additional tasks
into <code>s</code>. When the closure returns, it will block until all tasks
that have been spawned into <code>s</code> complete.</dd><dt><a class="fn" href="fn.join.html" title="fn maybe_rayon::join">join</a></dt><dd>Takes two closures and <em>potentially</em> runs them in parallel. It
returns a pair of the results from those closures.</dd><dt><a class="fn" href="fn.join_context.html" title="fn maybe_rayon::join_context">join_<wbr>context</a></dt><dd>Identical to <code>join</code>, except that the closures have a parameter
that provides context for the way the closure has been called,
especially indicating whether they’re executing on a different
thread than where <code>join_context</code> was called.  This will occur if
the second job is stolen by a different thread, or if
<code>join_context</code> was called from outside the thread pool to begin
with.</dd><dt><a class="fn" href="fn.max_num_threads.html" title="fn maybe_rayon::max_num_threads">max_<wbr>num_<wbr>threads</a></dt><dd>Returns the maximum number of threads that Rayon supports in a single thread pool.</dd><dt><a class="fn" href="fn.scope.html" title="fn maybe_rayon::scope">scope</a></dt><dd>Creates a “fork-join” scope <code>s</code> and invokes the closure with a
reference to <code>s</code>. This closure can then spawn asynchronous tasks
into <code>s</code>. Those tasks may run asynchronously with respect to the
closure; they may themselves spawn additional tasks into <code>s</code>. When
the closure returns, it will block until all tasks that have been
spawned into <code>s</code> complete.</dd><dt><a class="fn" href="fn.scope_fifo.html" title="fn maybe_rayon::scope_fifo">scope_<wbr>fifo</a></dt><dd>Creates a “fork-join” scope <code>s</code> with FIFO order, and invokes the
closure with a reference to <code>s</code>. This closure can then spawn
asynchronous tasks into <code>s</code>. Those tasks may run asynchronously with
respect to the closure; they may themselves spawn additional tasks
into <code>s</code>. When the closure returns, it will block until all tasks
that have been spawned into <code>s</code> complete.</dd><dt><a class="fn" href="fn.spawn.html" title="fn maybe_rayon::spawn">spawn</a></dt><dd>Puts the task into the Rayon thread pool’s job queue in the “static”
or “global” scope. Just like a standard thread, this task is not
tied to the current stack frame, and hence it cannot hold any
references other than those with <code>'static</code> lifetime. If you want
to spawn a task that references stack data, use <a href="fn.scope.html" title="fn maybe_rayon::scope">the <code>scope()</code>
function</a> to create a scope.</dd><dt><a class="fn" href="fn.spawn_broadcast.html" title="fn maybe_rayon::spawn_broadcast">spawn_<wbr>broadcast</a></dt><dd>Spawns an asynchronous task on every thread in this thread pool. This task
will run in the implicit, global scope, which means that it may outlast the
current stack frame – therefore, it cannot capture any references onto the
stack (you will likely need a <code>move</code> closure).</dd><dt><a class="fn" href="fn.spawn_fifo.html" title="fn maybe_rayon::spawn_fifo">spawn_<wbr>fifo</a></dt><dd>Fires off a task into the Rayon thread pool in the “static” or
“global” scope.  Just like a standard thread, this task is not
tied to the current stack frame, and hence it cannot hold any
references other than those with <code>'static</code> lifetime. If you want
to spawn a task that references stack data, use <a href="fn.scope_fifo.html" title="fn maybe_rayon::scope_fifo">the <code>scope_fifo()</code>
function</a> to create a scope.</dd><dt><a class="fn" href="fn.yield_local.html" title="fn maybe_rayon::yield_local">yield_<wbr>local</a></dt><dd>Cooperatively yields execution to local Rayon work.</dd><dt><a class="fn" href="fn.yield_now.html" title="fn maybe_rayon::yield_now">yield_<wbr>now</a></dt><dd>Cooperatively yields execution to Rayon.</dd></dl></section></div></main></body></html>