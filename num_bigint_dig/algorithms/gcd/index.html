<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `gcd` mod in crate `num_bigint_dig`."><title>num_bigint_dig::algorithms::gcd - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="num_bigint_dig" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module gcd</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../num_bigint_dig/index.html">num_<wbr>bigint_<wbr>dig</a><span class="version">0.8.6</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module gcd</a></h2><h3><a href="#functions">Module Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In num_<wbr>bigint_<wbr>dig::<wbr>algorithms</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">num_bigint_dig</a>::<wbr><a href="../index.html">algorithms</a></div><h1>Module <span>gcd</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/num_bigint_dig/algorithms/gcd.rs.html#1-751">Source</a> </span></div><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.euclid_udpate.html" title="fn num_bigint_dig::algorithms::gcd::euclid_udpate">euclid_<wbr>udpate</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.extended_gcd.html" title="fn num_bigint_dig::algorithms::gcd::extended_gcd">extended_<wbr>gcd</a></dt><dd>Uses the lehemer algorithm.
Based on https://github.com/golang/go/blob/master/src/math/big/int.go#L612
If <code>extended</code> is set, the Bezout coefficients are calculated, otherwise they are <code>None</code>.</dd><dt><a class="fn" href="fn.lehmer_gcd.html" title="fn num_bigint_dig::algorithms::gcd::lehmer_gcd">lehmer_<wbr>gcd</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>lehmerGCD sets z to the greatest common divisor of a and b,
which both must be != 0, and returns z.
If x or y are not nil, their values are set such that z = a<em>x + b</em>y.
See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm L.
This implementation uses the improved condition by Collins requiring only one
quotient and avoiding the possibility of single Word overflow.
See Jebelean, â€œImproving the multiprecision Euclidean algorithmâ€,
Design and Implementation of Symbolic Computation Systems, pp 45-58.
The cosequences are updated according to Algorithm 10.45 from
Cohen et al. â€œHandbook of Elliptic and Hyperelliptic Curve Cryptographyâ€ pp 192.</dd><dt><a class="fn" href="fn.lehmer_simulate.html" title="fn num_bigint_dig::algorithms::gcd::lehmer_simulate">lehmer_<wbr>simulate</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Attempts to simulate several Euclidean update steps using leading digits of <code>a</code> and <code>b</code>.
It returns <code>u0</code>, <code>u1</code>, <code>v0</code>, <code>v1</code> such that <code>a</code> and <code>b</code> can be updated as:
a = u0 * a + v0 * b
b = u1 * a + v1 * b</dd><dt><a class="fn" href="fn.lehmer_update.html" title="fn num_bigint_dig::algorithms::gcd::lehmer_update">lehmer_<wbr>update</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.xgcd.html" title="fn num_bigint_dig::algorithms::gcd::xgcd">xgcd</a></dt><dd>XGCD sets z to the greatest common divisor of a and b and returns z.
If extended is true, XGCD returns their value such that z = a<em>x + b</em>y.</dd></dl></section></div></main></body></html>