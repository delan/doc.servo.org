<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Based on the minimum number of states required for a useful lazy DFA cache, this returns a heuristic minimum number of bytes of heap space required."><title>minimum_cache_capacity in regex_automata::hybrid::dfa - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">minimum_cache_capacity</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_<wbr>automata</a><span class="version">0.4.13</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In regex_<wbr>automata::<wbr>hybrid::<wbr>dfa</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">hybrid</a>::<wbr><a href="index.html">dfa</a></div><h1>Function <span class="fn">minimum_<wbr>cache_<wbr>capacity</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/regex_automata/hybrid/dfa.rs.html#4335-4392">Source</a> </span></div><pre class="rust item-decl"><code>fn minimum_cache_capacity(
    nfa: &amp;<a class="struct" href="../../nfa/thompson/struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>,
    classes: &amp;<a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct regex_automata::util::alphabet::ByteClasses">ByteClasses</a>,
    starts_for_each_pattern: <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.usize.html">usize</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Based on the minimum number of states required for a useful lazy DFA cache,
this returns a heuristic minimum number of bytes of heap space required.</p>
<p>This is a “heuristic” because the minimum it returns is likely bigger than
the true minimum. Namely, it assumes that each powerset NFA/DFA state uses
the maximum number of NFA states (all of them). This is likely bigger
than what is required in practice. Computing the true minimum effectively
requires determinization, which is probably too much work to do for a
simple check like this.</p>
<p>One of the issues with this approach IMO is that it requires that this
be in sync with the calculation above for computing how much heap memory
the DFA cache uses. If we get it wrong, it’s possible for example for the
minimum to be smaller than the computed heap memory, and thus, it may be
the case that we can’t add the required minimum number of states. That in
turn will make lazy DFA panic because we assume that we can add at least a
minimum number of states.</p>
<p>Another approach would be to always allow the minimum number of states to
be added to the lazy DFA cache, even if it exceeds the configured cache
limit. This does mean that the limit isn’t really a limit in all cases,
which is unfortunate. But it does at least guarantee that the lazy DFA can
always make progress, even if it is slow. (This approach is very similar to
enabling the ‘skip_cache_capacity_check’ config knob, except it wouldn’t
rely on cache size calculation. Instead, it would just always permit a
minimum number of states to be added.)</p>
</div></details></section></div></main></body></html>