<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Types and routines that support the wire format of finite automata."><title>regex_automata::util::wire - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module wire</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_<wbr>automata</a><span class="version">0.4.13</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module wire</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In regex_<wbr>automata::<wbr>util</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">util</a></div><h1>Module <span>wire</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/regex_automata/util/wire.rs.html#1-947">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Types and routines that support the wire format of finite automata.</p>
<p>Currently, this module just exports a few error types and some small helpers
for deserializing <a href="crate::dfa::dense::DFA">dense DFAs</a> using correct alignment.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AlignAs.html" title="struct regex_automata::util::wire::AlignAs">AlignAs</a></dt><dd>A hack to align a smaller type <code>B</code> with a bigger type <code>T</code>.</dd><dt><a class="struct" href="struct.DeserializeError.html" title="struct regex_automata::util::wire::DeserializeError">Deserialize<wbr>Error</a></dt><dd>An error that occurs when deserializing an object defined in this crate.</dd><dt><a class="struct" href="struct.SerializeError.html" title="struct regex_automata::util::wire::SerializeError">Serialize<wbr>Error</a></dt><dd>An error that occurs when serializing an object from this crate.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.BE.html" title="enum regex_automata::util::wire::BE">BE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Big endian writing.</dd><dt><a class="enum" href="enum.DeserializeErrorKind.html" title="enum regex_automata::util::wire::DeserializeErrorKind">Deserialize<wbr>Error<wbr>Kind</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="enum" href="enum.LE.html" title="enum regex_automata::util::wire::LE">LE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Little endian writing.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Endian.html" title="trait regex_automata::util::wire::Endian">Endian</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A simple trait for writing code generic over endianness.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.add.html" title="fn regex_automata::util::wire::add">add</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Add the given numbers, and on overflow, return an error that includes
â€˜whatâ€™ in the error message.</dd><dt><a class="fn" href="fn.alloc_aligned_buffer.html" title="fn regex_automata::util::wire::alloc_aligned_buffer">alloc_<wbr>aligned_<wbr>buffer</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Allocate a byte buffer of the given size, along with some initial padding
such that <code>buf[padding..]</code> has the same alignment as <code>T</code>, where the
alignment of <code>T</code> must be at most <code>8</code>. In particular, callers should treat
the first N bytes (second return value) as padding bytes that must not be
overwritten. In all cases, the following identity holds:</dd><dt><a class="fn" href="fn.check_alignment.html" title="fn regex_automata::util::wire::check_alignment">check_<wbr>alignment</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Checks that the given slice has an alignment that matches <code>T</code>.</dd><dt><a class="fn" href="fn.check_slice_len.html" title="fn regex_automata::util::wire::check_slice_len">check_<wbr>slice_<wbr>len</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Checks that the given slice has some minimal length. If itâ€™s smaller than
the bound given, then a â€œbuffer too smallâ€ error is returned with <code>what</code>
describing what the buffer represents.</dd><dt><a class="fn" href="fn.mul.html" title="fn regex_automata::util::wire::mul">mul</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Multiply the given numbers, and on overflow, return an error that includes
â€˜whatâ€™ in the error message.</dd><dt><a class="fn" href="fn.padding_len.html" title="fn regex_automata::util::wire::padding_len">padding_<wbr>len</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Returns the number of additional bytes required to add to the given length
in order to make the total length a multiple of 4. The return value is
always less than 4.</dd><dt><a class="fn" href="fn.read_endianness_check.html" title="fn regex_automata::util::wire::read_endianness_check">read_<wbr>endianness_<wbr>check</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads the endianness check from the beginning of the given slice and
confirms that the endianness of the serialized object matches the expected
endianness. If the slice is too small or if the endianness check fails,
this returns an error.</dd><dt><a class="fn" href="fn.read_label.html" title="fn regex_automata::util::wire::read_label">read_<wbr>label</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads a NUL terminated label starting at the beginning of the given slice.</dd><dt><a class="fn" href="fn.read_pattern_id.html" title="fn regex_automata::util::wire::read_pattern_id">read_<wbr>pattern_<wbr>id</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads a pattern ID from the given slice. If the slice has insufficient
length, then this panics. If the deserialized integer exceeds the pattern
ID limit for the current target, then this returns an error.</dd><dt><a class="fn" href="fn.read_pattern_id_unchecked.html" title="fn regex_automata::util::wire::read_pattern_id_unchecked">read_<wbr>pattern_<wbr>id_<wbr>unchecked</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads a pattern ID from the given slice. If the slice has insufficient
length, then this panics. Otherwise, the deserialized integer is assumed
to be a valid pattern ID.</dd><dt><a class="fn" href="fn.read_state_id.html" title="fn regex_automata::util::wire::read_state_id">read_<wbr>state_<wbr>id</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads a state ID from the given slice. If the slice has insufficient
length, then this panics. If the deserialized integer exceeds the state ID
limit for the current target, then this returns an error.</dd><dt><a class="fn" href="fn.read_state_id_unchecked.html" title="fn regex_automata::util::wire::read_state_id_unchecked">read_<wbr>state_<wbr>id_<wbr>unchecked</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads a state ID from the given slice. If the slice has insufficient
length, then this panics. Otherwise, the deserialized integer is assumed
to be a valid state ID.</dd><dt><a class="fn" href="fn.read_u16.html" title="fn regex_automata::util::wire::read_u16">read_<wbr>u16</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Read a u16 from the beginning of the given slice in native endian format.
If the slice has fewer than 2 bytes, then this panics.</dd><dt><a class="fn" href="fn.read_u32.html" title="fn regex_automata::util::wire::read_u32">read_<wbr>u32</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Read a u32 from the beginning of the given slice in native endian format.
If the slice has fewer than 4 bytes, then this panics.</dd><dt><a class="fn" href="fn.read_u128.html" title="fn regex_automata::util::wire::read_u128">read_<wbr>u128</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Read a u128 from the beginning of the given slice in native endian format.
If the slice has fewer than 16 bytes, then this panics.</dd><dt><a class="fn" href="fn.read_version.html" title="fn regex_automata::util::wire::read_version">read_<wbr>version</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads a version number from the beginning of the given slice and confirms
that is matches the expected version number given. If the slice is too
small or if the version numbers arenâ€™t equivalent, this returns an error.</dd><dt><a class="fn" href="fn.shl.html" title="fn regex_automata::util::wire::shl">shl</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Shift <code>a</code> left by <code>b</code>, and on overflow, return an error that includes
â€˜whatâ€™ in the error message.</dd><dt><a class="fn" href="fn.skip_initial_padding.html" title="fn regex_automata::util::wire::skip_initial_padding">skip_<wbr>initial_<wbr>padding</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reads a possibly empty amount of padding, up to 7 bytes, from the beginning
of the given slice. All padding bytes must be NUL bytes.</dd><dt><a class="fn" href="fn.try_read_state_id.html" title="fn regex_automata::util::wire::try_read_state_id">try_<wbr>read_<wbr>state_<wbr>id</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Attempts to read a state ID from the given slice. If the slice has an
insufficient number of bytes or if the state ID exceeds the limit for
the current target, then this returns an error.</dd><dt><a class="fn" href="fn.try_read_u16.html" title="fn regex_automata::util::wire::try_read_u16">try_<wbr>read_<wbr>u16</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Try to read a u16 from the beginning of the given slice in native endian
format. If the slice has fewer than 2 bytes, then this returns an error.
The error message will include the <code>what</code> description of what is being
deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</dd><dt><a class="fn" href="fn.try_read_u32.html" title="fn regex_automata::util::wire::try_read_u32">try_<wbr>read_<wbr>u32</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Try to read a u32 from the beginning of the given slice in native endian
format. If the slice has fewer than 4 bytes, then this returns an error.
The error message will include the <code>what</code> description of what is being
deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</dd><dt><a class="fn" href="fn.try_read_u16_as_usize.html" title="fn regex_automata::util::wire::try_read_u16_as_usize">try_<wbr>read_<wbr>u16_<wbr>as_<wbr>usize</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Try to read a u16 as a usize from the beginning of the given slice in
native endian format. If the slice has fewer than 2 bytes or if the
deserialized number cannot be represented by usize, then this returns an
error. The error message will include the <code>what</code> description of what is
being deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</dd><dt><a class="fn" href="fn.try_read_u32_as_usize.html" title="fn regex_automata::util::wire::try_read_u32_as_usize">try_<wbr>read_<wbr>u32_<wbr>as_<wbr>usize</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Try to read a u32 as a usize from the beginning of the given slice in
native endian format. If the slice has fewer than 4 bytes or if the
deserialized number cannot be represented by usize, then this returns an
error. The error message will include the <code>what</code> description of what is
being deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</dd><dt><a class="fn" href="fn.try_read_u128.html" title="fn regex_automata::util::wire::try_read_u128">try_<wbr>read_<wbr>u128</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Try to read a u128 from the beginning of the given slice in native endian
format. If the slice has fewer than 16 bytes, then this returns an error.
The error message will include the <code>what</code> description of what is being
deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</dd><dt><a class="fn" href="fn.u32s_to_pattern_ids.html" title="fn regex_automata::util::wire::u32s_to_pattern_ids">u32s_<wbr>to_<wbr>pattern_<wbr>ids</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Safely converts a <code>&amp;[u32]</code> to <code>&amp;[PatternID]</code> with zero cost.</dd><dt><a class="fn" href="fn.u32s_to_state_ids.html" title="fn regex_automata::util::wire::u32s_to_state_ids">u32s_<wbr>to_<wbr>state_<wbr>ids</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Safely converts a <code>&amp;[u32]</code> to <code>&amp;[StateID]</code> with zero cost.</dd><dt><a class="fn" href="fn.u32s_to_state_ids_mut.html" title="fn regex_automata::util::wire::u32s_to_state_ids_mut">u32s_<wbr>to_<wbr>state_<wbr>ids_<wbr>mut</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Safely converts a <code>&amp;mut [u32]</code> to <code>&amp;mut [StateID]</code> with zero cost.</dd><dt><a class="fn" href="fn.write_endianness_check.html" title="fn regex_automata::util::wire::write_endianness_check">write_<wbr>endianness_<wbr>check</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Writes 0xFEFF as an integer using the given endianness.</dd><dt><a class="fn" href="fn.write_endianness_check_len.html" title="fn regex_automata::util::wire::write_endianness_check_len">write_<wbr>endianness_<wbr>check_<wbr>len</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Returns the number of bytes written by the endianness check.</dd><dt><a class="fn" href="fn.write_label.html" title="fn regex_automata::util::wire::write_label">write_<wbr>label</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Writes the given label to the buffer as a NUL terminated string. The label
given must not contain NUL, otherwise this will panic. Similarly, the label
must not be longer than 255 bytes, otherwise this will panic.</dd><dt><a class="fn" href="fn.write_label_len.html" title="fn regex_automata::util::wire::write_label_len">write_<wbr>label_<wbr>len</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Returns the total number of bytes (including padding) that would be written
for the given label. This panics if the given label contains a NUL byte or
is longer than 255 bytes. (The size restriction exists so that searching
for a label during deserialization can be done in small bounded space.)</dd><dt><a class="fn" href="fn.write_pattern_id.html" title="fn regex_automata::util::wire::write_pattern_id">write_<wbr>pattern_<wbr>id</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Write the given pattern ID to the beginning of the given slice of bytes
using the specified endianness. The given slice must have length at least
<code>PatternID::SIZE</code>, or else this panics. Upon success, the total number of
bytes written is returned.</dd><dt><a class="fn" href="fn.write_state_id.html" title="fn regex_automata::util::wire::write_state_id">write_<wbr>state_<wbr>id</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Write the given state ID to the beginning of the given slice of bytes
using the specified endianness. The given slice must have length at least
<code>StateID::SIZE</code>, or else this panics. Upon success, the total number of
bytes written is returned.</dd><dt><a class="fn" href="fn.write_version.html" title="fn regex_automata::util::wire::write_version">write_<wbr>version</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Writes the given version number to the beginning of the given slice.</dd><dt><a class="fn" href="fn.write_version_len.html" title="fn regex_automata::util::wire::write_version_len">write_<wbr>version_<wbr>len</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Returns the number of bytes written by writing the version number.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.NE.html" title="type regex_automata::util::wire::NE">NE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl></section></div></main></body></html>