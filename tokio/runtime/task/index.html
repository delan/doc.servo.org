<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The task module."><title>tokio::runtime::task - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="tokio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module task</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../tokio/index.html">tokio</a><span class="version">1.49.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module task</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#task-reference-types" title="Task reference types">Task reference types</a></li><li><a href="#state" title="State">State</a></li><li><a href="#fields-in-the-task" title="Fields in the task">Fields in the task</a></li><li><a href="#safety" title="Safety">Safety</a><ul><li><a href="#polling-or-dropping-the-future" title="Polling or dropping the future">Polling or dropping the future</a></li><li><a href="#non-send-futures" title="Non-Send futures">Non-Send futures</a></li><li><a href="#non-send-output" title="Non-Send output">Non-Send output</a></li><li><a href="#recursive-pollshutdown" title="Recursive poll/shutdown">Recursive poll/shutdown</a></li></ul></li></ul><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In tokio::<wbr>runtime</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">tokio</a>::<wbr><a href="../index.html">runtime</a></div><h1>Module <span>task</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/tokio/runtime/task/mod.rs.html#1-670">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The task module.</p>
<p>The task module contains the code that manages spawned tasks and provides a
safe API for the rest of the runtime to use. Each task in a runtime is
stored in an <code>OwnedTasks</code> or <code>LocalOwnedTasks</code> object.</p>
<h2 id="task-reference-types"><a class="doc-anchor" href="#task-reference-types">Â§</a>Task reference types</h2>
<p>A task is usually referenced by multiple handles, and there are several
types of handles.</p>
<ul>
<li>
<p><code>OwnedTask</code> - tasks stored in an <code>OwnedTasks</code> or <code>LocalOwnedTasks</code> are of this
reference type.</p>
</li>
<li>
<p><code>JoinHandle</code> - each task has a <code>JoinHandle</code> that allows access to the output
of the task.</p>
</li>
<li>
<p><code>Waker</code> - every waker for a task has this reference type. There can be any
number of waker references.</p>
</li>
<li>
<p><code>Notified</code> - tracks whether the task is notified.</p>
</li>
<li>
<p><code>Unowned</code> - this task reference type is used for tasks not stored in any
runtime. Mainly used for blocking tasks, but also in tests.</p>
</li>
</ul>
<p>The task uses a reference count to keep track of how many active references
exist. The <code>Unowned</code> reference type takes up two ref-counts. All other
reference types take up a single ref-count.</p>
<p>Besides the waker type, each task has at most one of each reference type.</p>
<h2 id="state"><a class="doc-anchor" href="#state">Â§</a>State</h2>
<p>The task stores its state in an atomic <code>usize</code> with various bitfields for the
necessary information. The state has the following bitfields:</p>
<ul>
<li>
<p><code>RUNNING</code> - Tracks whether the task is currently being polled or cancelled.
This bit functions as a lock around the task.</p>
</li>
<li>
<p><code>COMPLETE</code> - Is one once the future has fully completed and has been
dropped. Never unset once set. Never set together with RUNNING.</p>
</li>
<li>
<p><code>NOTIFIED</code> - Tracks whether a Notified object currently exists.</p>
</li>
<li>
<p><code>CANCELLED</code> - Is set to one for tasks that should be cancelled as soon as
possible. May take any value for completed tasks.</p>
</li>
<li>
<p><code>JOIN_INTEREST</code> - Is set to one if there exists a <code>JoinHandle</code>.</p>
</li>
<li>
<p><code>JOIN_WAKER</code> - Acts as an access control bit for the join handle waker. The
protocol for its usage is described below.</p>
</li>
</ul>
<p>The rest of the bits are used for the ref-count.</p>
<h2 id="fields-in-the-task"><a class="doc-anchor" href="#fields-in-the-task">Â§</a>Fields in the task</h2>
<p>The task has various fields. This section describes how and when it is safe
to access a field.</p>
<ul>
<li>
<p>The state field is accessed with atomic instructions.</p>
</li>
<li>
<p>The <code>OwnedTask</code> reference has exclusive access to the <code>owned</code> field.</p>
</li>
<li>
<p>The Notified reference has exclusive access to the <code>queue_next</code> field.</p>
</li>
<li>
<p>The <code>owner_id</code> field can be set as part of construction of the task, but
is otherwise immutable and anyone can access the field immutably without
synchronization.</p>
</li>
<li>
<p>If COMPLETE is one, then the <code>JoinHandle</code> has exclusive access to the
stage field. If COMPLETE is zero, then the RUNNING bitfield functions as
a lock for the stage field, and it can be accessed only by the thread
that set RUNNING to one.</p>
</li>
<li>
<p>The waker field may be concurrently accessed by different threads: in one
thread the runtime may complete a task and <em>read</em> the waker field to
invoke the waker, and in another thread the taskâ€™s <code>JoinHandle</code> may be
polled, and if the task hasnâ€™t yet completed, the <code>JoinHandle</code> may <em>write</em>
a waker to the waker field. The <code>JOIN_WAKER</code> bit ensures safe access by
multiple threads to the waker field using the following rules:</p>
<ol>
<li>
<p><code>JOIN_WAKER</code> is initialized to zero.</p>
</li>
<li>
<p>If <code>JOIN_WAKER</code> is zero, then the <code>JoinHandle</code> has exclusive (mutable)
access to the waker field.</p>
</li>
<li>
<p>If <code>JOIN_WAKER</code> is one, then the <code>JoinHandle</code> has shared (read-only)
access to the waker field.</p>
</li>
<li>
<p>If <code>JOIN_WAKER</code> is one and COMPLETE is one, then the runtime has shared
(read-only) access to the waker field.</p>
</li>
<li>
<p>If the <code>JoinHandle</code> needs to write to the waker field, then the
<code>JoinHandle</code> needs to (i) successfully set <code>JOIN_WAKER</code> to zero if it is
not already zero to gain exclusive access to the waker field per rule
2, (ii) write a waker, and (iii) successfully set <code>JOIN_WAKER</code> to one.
If the <code>JoinHandle</code> unsets <code>JOIN_WAKER</code> in the process of being dropped
to clear the waker field, only steps (i) and (ii) are relevant.</p>
</li>
<li>
<p>The <code>JoinHandle</code> can change <code>JOIN_WAKER</code> only if COMPLETE is zero (i.e.
the task hasnâ€™t yet completed). The runtime can change <code>JOIN_WAKER</code> only
if COMPLETE is one.</p>
</li>
<li>
<p>If <code>JOIN_INTEREST</code> is zero and COMPLETE is one, then the runtime has
exclusive (mutable) access to the waker field. This might happen if the
<code>JoinHandle</code> gets dropped right after the task completes and the runtime
sets the <code>COMPLETE</code> bit. In this case the runtime needs the mutable access
to the waker field to drop it.</p>
</li>
</ol>
<p>Rule 6 implies that the steps (i) or (iii) of rule 5 may fail due to a
race. If step (i) fails, then the attempt to write a waker is aborted. If
step (iii) fails because COMPLETE is set to one by another thread after
step (i), then the waker field is cleared. Once COMPLETE is one (i.e.
task has completed), the <code>JoinHandle</code> will not modify <code>JOIN_WAKER</code>. After the
runtime sets COMPLETE to one, it invokes the waker if there is one so in this
case when a task completes the <code>JOIN_WAKER</code> bit implicates to the runtime
whether it should invoke the waker or not. After the runtime is done with
using the waker during task completion, it unsets the <code>JOIN_WAKER</code> bit to give
the <code>JoinHandle</code> exclusive access again so that it is able to drop the waker
at a later point.</p>
</li>
</ul>
<p>All other fields are immutable and can be accessed immutably without
synchronization by anyone.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">Â§</a>Safety</h2>
<p>This section goes through various situations and explains why the API is
safe in that situation.</p>
<h3 id="polling-or-dropping-the-future"><a class="doc-anchor" href="#polling-or-dropping-the-future">Â§</a>Polling or dropping the future</h3>
<p>Any mutable access to the future happens after obtaining a lock by modifying
the RUNNING field, so exclusive access is ensured.</p>
<p>When the task completes, exclusive access to the output is transferred to
the <code>JoinHandle</code>. If the <code>JoinHandle</code> is already dropped when the transition to
complete happens, the thread performing that transition retains exclusive
access to the output and should immediately drop it.</p>
<h3 id="non-send-futures"><a class="doc-anchor" href="#non-send-futures">Â§</a>Non-Send futures</h3>
<p>If a future is not Send, then it is bound to a <code>LocalOwnedTasks</code>.  The future
will only ever be polled or dropped given a <code>LocalNotified</code> or inside a call
to <code>LocalOwnedTasks::shutdown_all</code>. In either case, it is guaranteed that the
future is on the right thread.</p>
<p>If the task is never removed from the <code>LocalOwnedTasks</code>, then it is leaked, so
there is no risk that the task is dropped on some other thread when the last
ref-count drops.</p>
<h3 id="non-send-output"><a class="doc-anchor" href="#non-send-output">Â§</a>Non-Send output</h3>
<p>When a task completes, the output is placed in the stage of the task. Then,
a transition that sets COMPLETE to true is performed, and the value of
<code>JOIN_INTEREST</code> when this transition happens is read.</p>
<p>If <code>JOIN_INTEREST</code> is zero when the transition to COMPLETE happens, then the
output is immediately dropped.</p>
<p>If <code>JOIN_INTEREST</code> is one when the transition to COMPLETE happens, then the
<code>JoinHandle</code> is responsible for cleaning up the output. If the output is not
Send, then this happens:</p>
<ol>
<li>The output is created on the thread that the future was polled on. Since
only non-Send futures can have non-Send output, the future was polled on
the thread that the future was spawned from.</li>
<li>Since <code>JoinHandle&lt;Output&gt;</code> is not Send if Output is not Send, the
<code>JoinHandle</code> is also on the thread that the future was spawned from.</li>
<li>Thus, the <code>JoinHandle</code> will not move the output across threads when it
takes or drops the output.</li>
</ol>
<h3 id="recursive-pollshutdown"><a class="doc-anchor" href="#recursive-pollshutdown">Â§</a>Recursive poll/shutdown</h3>
<p>Calling poll from inside a shutdown call or vice-versa is not prevented by
the API exposed by the task module, so this has to be safe. In either case,
the lock in the RUNNING bitfield makes the inner call return immediately. If
the inner call is a <code>shutdown</code> call, then the CANCELLED bit is set, and the
poll call will notice it when the poll finishes, and the task is cancelled
at that point.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">Â§</a></h2><dl class="item-table reexports"><dt id="reexport.JoinError"><code>pub use self::error::<a class="struct" href="../../task/struct.JoinError.html" title="struct tokio::task::JoinError">JoinError</a>;</code></dt><dt id="reexport.id"><code>pub use id::<a class="fn" href="../../task/fn.id.html" title="fn tokio::task::id">id</a>;</code></dt><dt id="reexport.try_id"><code>pub use id::<a class="fn" href="../../task/fn.try_id.html" title="fn tokio::task::try_id">try_id</a>;</code></dt><dt id="reexport.Id"><code>pub use id::<a class="struct" href="../../task/struct.Id.html" title="struct tokio::task::Id">Id</a>;</code></dt><dt id="reexport.AbortHandle"><code>pub use self::abort::<a class="struct" href="../../task/struct.AbortHandle.html" title="struct tokio::task::AbortHandle">AbortHandle</a>;</code></dt><dt id="reexport.JoinHandle"><code>pub use self::join::<a class="struct" href="../../task/struct.JoinHandle.html" title="struct tokio::task::JoinHandle">JoinHandle</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="abort/index.html" title="mod tokio::runtime::task::abort">abort</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="core/index.html" title="mod tokio::runtime::task::core">core</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Core task module.</dd><dt><a class="mod" href="error/index.html" title="mod tokio::runtime::task::error">error</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="harness/index.html" title="mod tokio::runtime::task::harness">harness</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="id/index.html" title="mod tokio::runtime::task::id">id</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="join/index.html" title="mod tokio::runtime::task::join">join</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="list/index.html" title="mod tokio::runtime::task::list">list</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>This module has containers for storing the tasks spawned on a scheduler. The
<code>OwnedTasks</code> container is thread-safe but can only store tasks that
implement Send. The <code>LocalOwnedTasks</code> container is not thread safe, but can
store non-Send tasks.</dd><dt><a class="mod" href="raw/index.html" title="mod tokio::runtime::task::raw">raw</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="spawn_location/index.html" title="mod tokio::runtime::task::spawn_location">spawn_<wbr>location</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="state/index.html" title="mod tokio::runtime::task::state">state</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="waker/index.html" title="mod tokio::runtime::task::waker">waker</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.LocalNotified.html" title="struct tokio::runtime::task::LocalNotified">Local<wbr>Notified</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>A non-Send variant of Notified with the invariant that it is on a thread
where it is safe to poll it.</dd><dt><a class="struct" href="struct.Notified.html" title="struct tokio::runtime::task::Notified">Notified</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>A task was notified.</dd><dt><a class="struct" href="struct.Task.html" title="struct tokio::runtime::task::Task">Task</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>An owned handle to the task, tracked by ref count.</dd><dt><a class="struct" href="struct.TaskHarnessScheduleHooks.html" title="struct tokio::runtime::task::TaskHarnessScheduleHooks">Task<wbr>Harness<wbr>Schedule<wbr>Hooks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Hooks for scheduling tasks which are needed in the task harness.</dd><dt><a class="struct" href="struct.UnownedTask.html" title="struct tokio::runtime::task::UnownedTask">Unowned<wbr>Task</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>A task that is not owned by any <code>OwnedTasks</code>. Used for blocking tasks.
This type holds two ref-counts.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Schedule.html" title="trait tokio::runtime::task::Schedule">Schedule</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.new_task.html" title="fn tokio::runtime::task::new_task">new_<wbr>task</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>This is the constructor for a new task. Three references to the task are
created. The first task reference is usually put into an <code>OwnedTasks</code>
immediately. The Notified is sent to the scheduler as an ordinary
notification.</dd><dt><a class="fn" href="fn.unowned.html" title="fn tokio::runtime::task::unowned">unowned</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Creates a new task with an associated join handle. This method is used
only when the task is not going to be stored in an <code>OwnedTasks</code> list.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.Result.html" title="type tokio::runtime::task::Result">Result</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Task result sent back.</dd></dl></section></div></main></body></html>