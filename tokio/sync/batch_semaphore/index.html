<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation Details."><title>tokio::sync::batch_semaphore - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="tokio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module batch_semaphore</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../tokio/index.html">tokio</a><span class="version">1.49.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module batch_<wbr>semaphore</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#implementation-details" title="Implementation Details.">Implementation Details.</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In tokio::<wbr>sync</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">tokio</a>::<wbr><a href="../index.html">sync</a></div><h1>Module <span>batch_<wbr>semaphore</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/tokio/sync/batch_semaphore.rs.html#1-780">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="implementation-details"><a class="doc-anchor" href="#implementation-details">Â§</a>Implementation Details.</h2>
<p>The semaphore is implemented using an intrusive linked list of waiters. An
atomic counter tracks the number of available permits. If the semaphore does
not contain the required number of permits, the task attempting to acquire
permits places its waker at the end of a queue. When new permits are made
available (such as by releasing an initial acquisition), they are assigned
to the task at the front of the queue, waking that task if its requested
number of permits is met.</p>
<p>Because waiters are enqueued at the back of the linked list and dequeued
from the front, the semaphore is fair. Tasks trying to acquire large numbers
of permits at a time will always be woken eventually, even if many other
tasks are acquiring smaller numbers of permits. This means that in a
use-case like tokioâ€™s read-write lock, writers will not be starved by
readers.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Acquire.html" title="struct tokio::sync::batch_semaphore::Acquire">Acquire</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="struct" href="struct.AcquireError.html" title="struct tokio::sync::batch_semaphore::AcquireError">Acquire<wbr>Error</a></dt><dd>Error returned from the <a href="../struct.Semaphore.html#method.acquire" title="method tokio::sync::Semaphore::acquire"><code>Semaphore::acquire</code></a> function.</dd><dt><a class="struct" href="struct.Semaphore.html" title="struct tokio::sync::batch_semaphore::Semaphore">Semaphore</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>An asynchronous counting semaphore which permits waiting on multiple permits at once.</dd><dt><a class="struct" href="struct.Waiter.html" title="struct tokio::sync::batch_semaphore::Waiter">Waiter</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>An entry in the wait queue.</dd><dt><a class="struct" href="struct.Waitlist.html" title="struct tokio::sync::batch_semaphore::Waitlist">Waitlist</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.TryAcquireError.html" title="enum tokio::sync::batch_semaphore::TryAcquireError">TryAcquire<wbr>Error</a></dt><dd>Error returned from the <a href="../struct.Semaphore.html#method.try_acquire" title="method tokio::sync::Semaphore::try_acquire"><code>Semaphore::try_acquire</code></a> function.</dd></dl></section></div></main></body></html>