<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A picture represents a dynamically rendered image."><title>webrender::picture - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="webrender" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module picture</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../webrender/index.html">webrender</a><span class="version">0.68.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module picture</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#overview" title="Overview">Overview</a><ul><li><a href="#picture-caching" title="Picture caching">Picture caching</a></li><li><a href="#invalidation" title="Invalidation">Invalidation</a></li><li><a href="#display-list-shape" title="Display List shape">Display List shape</a></li><li><a href="#compositor-surfaces" title="Compositor Surfaces">Compositor Surfaces</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate webrender</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">webrender</a></div><h1>Module <span>picture</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/webrender/picture.rs.html#5-8668">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A picture represents a dynamically rendered image.</p>
<h2 id="overview"><a class="doc-anchor" href="#overview">Â§</a>Overview</h2>
<p>Pictures consists of:</p>
<ul>
<li>A number of primitives that are drawn onto the picture.</li>
<li>A composite operation describing how to composite this
picture into its parent.</li>
<li>A configuration describing how to draw the primitives on
this picture (e.g. in screen space or local space).</li>
</ul>
<p>The tree of pictures are generated during scene building.</p>
<p>Depending on their composite operations pictures can be rendered into
intermediate targets or folded into their parent picture.</p>
<h3 id="picture-caching"><a class="doc-anchor" href="#picture-caching">Â§</a>Picture caching</h3>
<p>Pictures can be cached to reduce the amount of rasterization happening per
frame.</p>
<p>When picture caching is enabled, the scene is cut into a small number of slices,
typically:</p>
<ul>
<li>content slice</li>
<li>UI slice</li>
<li>background UI slice which is hidden by the other two slices most of the time.</li>
</ul>
<p>Each of these slice is made up of fixed-size large tiles of 2048x512 pixels
(or 128x128 for the UI slice).</p>
<p>Tiles can be either cached rasterized content into a texture or â€œclear tilesâ€
that contain only a solid color rectangle rendered directly during the composite
pass.</p>
<h3 id="invalidation"><a class="doc-anchor" href="#invalidation">Â§</a>Invalidation</h3>
<p>Each tile keeps track of the elements that affect it, which can be:</p>
<ul>
<li>primitives</li>
<li>clips</li>
<li>image keys</li>
<li>opacity bindings</li>
<li>transforms</li>
</ul>
<p>These dependency lists are built each frame and compared to the previous frame to
see if the tile changed.</p>
<p>The tileâ€™s primitive dependency information is organized in a quadtree, each node
storing an index buffer of tile primitive dependencies.</p>
<p>The union of the invalidated leaves of each quadtree produces a per-tile dirty rect
which defines the scissor rect used when replaying the tileâ€™s drawing commands and
can be used for partial present.</p>
<h3 id="display-list-shape"><a class="doc-anchor" href="#display-list-shape">Â§</a>Display List shape</h3>
<p>WR will first look for an iframe item in the root stacking context to apply
picture caching to. If thatâ€™s not found, it will apply to the entire root
stacking context of the display list. Apart from that, the format of the
display list is not important to picture caching. Each time a new scroll root
is encountered, a new picture cache slice will be created. If the display
list contains more than some arbitrary number of slices (currently 8), the
content will all be squashed into a single slice, in order to save GPU memory
and compositing performance.</p>
<h3 id="compositor-surfaces"><a class="doc-anchor" href="#compositor-surfaces">Â§</a>Compositor Surfaces</h3>
<p>Sometimes, a primitive would prefer to exist as a native compositor surface.
This allows a large and/or regularly changing primitive (such as a video, or
webgl canvas) to be updated each frame without invalidating the content of
tiles, and can provide a significant performance win and battery saving.</p>
<p>Since drawing a primitive as a compositor surface alters the ordering of
primitives in a tile, we use â€˜overlay tilesâ€™ to ensure correctness. If a
tile has a compositor surface, <em>and</em> that tile has primitives that overlap
the compositor surface rect, the tile switches to be drawn in alpha mode.</p>
<p>We rely on only promoting compositor surfaces that are opaque primitives.
With this assumption, the tile(s) that intersect the compositor surface get
a â€˜cutoutâ€™ in the rectangle where the compositor surface exists (not the
entire tile), allowing that tile to be drawn as an alpha tile after the
compositor surface.</p>
<p>Tiles are only drawn in overlay mode if there is content that exists on top
of the compositor surface. Otherwise, we can draw the tiles in the normal fast
path before the compositor surface is drawn. Use of the per-tile valid and
dirty rects ensure that we do a minimal amount of per-pixel work here to
blend the overlay tile (this is not always optimal right now, but will be
improved as a follow up).</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BackdropInfo.html" title="struct webrender::picture::BackdropInfo">Backdrop<wbr>Info</a></dt><dd>Stores information about the calculated opaque backdrop of this slice.</dd><dt><a class="struct" href="struct.BackdropSurface.html" title="struct webrender::picture::BackdropSurface">Backdrop<wbr>Surface</a></dt><dt><a class="struct" href="struct.BindingInfo.html" title="struct webrender::picture::BindingInfo">Binding<wbr>Info</a></dt><dd>Information about the state of a binding.</dd><dt><a class="struct" href="struct.BlitReason.html" title="struct webrender::picture::BlitReason">Blit<wbr>Reason</a></dt><dd>A set of flags describing why a picture may need a backing surface.</dd><dt><a class="struct" href="struct.ClusterFlags.html" title="struct webrender::picture::ClusterFlags">Cluster<wbr>Flags</a></dt><dd>A set of flags describing why a picture may need a backing surface.</dd><dt><a class="struct" href="struct.CompositorSurface.html" title="struct webrender::picture::CompositorSurface">Compositor<wbr>Surface</a></dt><dd>Wrapper struct around an external surface descriptor with a little more information
that the picture caching code needs.</dd><dt><a class="struct" href="struct.DeferredDirtyTest.html" title="struct webrender::picture::DeferredDirtyTest">Deferred<wbr>Dirty<wbr>Test</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>In some cases, we need to know the dirty rect of all tiles in order
to correctly invalidate a primitive.</dd><dt><a class="struct" href="struct.DirtyRegion.html" title="struct webrender::picture::DirtyRegion">Dirty<wbr>Region</a></dt><dd>Represents the dirty region of a tile cache picture, relative to a
â€œvisibilityâ€ spatial node. At the moment the visibility node is
world space, but the plan is to switch to raster space.</dd><dt><a class="struct" href="struct.ExternalNativeSurface.html" title="struct webrender::picture::ExternalNativeSurface">External<wbr>Native<wbr>Surface</a></dt><dd>Information about a native compositor surface cached between frames.</dd><dt><a class="struct" href="struct.ExternalNativeSurfaceKey.html" title="struct webrender::picture::ExternalNativeSurfaceKey">External<wbr>Native<wbr>Surface<wbr>Key</a></dt><dd>Hash key for an external native compositor surface</dd><dt><a class="struct" href="struct.ImageDependency.html" title="struct webrender::picture::ImageDependency">Image<wbr>Dependency</a></dt><dd>Information stored an image dependency</dd><dt><a class="struct" href="struct.MatrixKey.html" title="struct webrender::picture::MatrixKey">Matrix<wbr>Key</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A comparable transform matrix, that compares with epsilon checks.</dd><dt><a class="struct" href="struct.NativeSurface.html" title="struct webrender::picture::NativeSurface">Native<wbr>Surface</a></dt><dd>Represents the native surfaces created for a picture cache, if using
a native compositor. An opaque and alpha surface is always created,
but tiles are added to a surface based on current opacity. If the
calculated opacity of a tile changes, the tile is invalidated and
attached to a different native surface. This means that we donâ€™t
need to invalidate the entire surface if only some tiles are changing
opacity. It also means we can take advantage of opaque tiles on cache
slices where only some of the tiles are opaque. There is an assumption
that creating a native surface is cheap, and only when a tile is added
to a surface is there a significant cost. This assumption holds true
for the current native compositor implementations on Windows and Mac.</dd><dt><a class="struct" href="struct.OrderedPictureChild.html" title="struct webrender::picture::OrderedPictureChild">Ordered<wbr>Picture<wbr>Child</a></dt><dd>Information about a preserve-3D hierarchy child that has been plane-split
and ordered according to the view direction.</dd><dt><a class="struct" href="struct.PictureFlags.html" title="struct webrender::picture::PictureFlags">Picture<wbr>Flags</a></dt><dd>Flags describing properties for a given PicturePrimitive</dd><dt><a class="struct" href="struct.PicturePrimitive.html" title="struct webrender::picture::PicturePrimitive">Picture<wbr>Primitive</a></dt><dt><a class="struct" href="struct.PictureScratchBuffer.html" title="struct webrender::picture::PictureScratchBuffer">Picture<wbr>Scratch<wbr>Buffer</a></dt><dt><a class="struct" href="struct.PrimitiveCluster.html" title="struct webrender::picture::PrimitiveCluster">Primitive<wbr>Cluster</a></dt><dd>Descriptor for a cluster of primitives. For now, this is quite basic but will be
extended to handle more spatial clustering of primitives.</dd><dt><a class="struct" href="struct.PrimitiveComparer.html" title="struct webrender::picture::PrimitiveComparer">Primitive<wbr>Comparer</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A helper struct to compare a primitive and all its sub-dependencies.</dd><dt><a class="struct" href="struct.PrimitiveComparisonKey.html" title="struct webrender::picture::PrimitiveComparisonKey">Primitive<wbr>Comparison<wbr>Key</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A key for storing primitive comparison results during tile dependency tests.</dd><dt><a class="struct" href="struct.PrimitiveDependencyIndex.html" title="struct webrender::picture::PrimitiveDependencyIndex">Primitive<wbr>Dependency<wbr>Index</a></dt><dd>An index into the prims array in a TileDescriptor.</dd><dt><a class="struct" href="struct.PrimitiveDependencyInfo.html" title="struct webrender::picture::PrimitiveDependencyInfo">Primitive<wbr>Dependency<wbr>Info</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Information about the dependencies of a single primitive instance.</dd><dt><a class="struct" href="struct.PrimitiveDescriptor.html" title="struct webrender::picture::PrimitiveDescriptor">Primitive<wbr>Descriptor</a></dt><dd>Defines a key that uniquely identifies a primitive instance.</dd><dt><a class="struct" href="struct.PrimitiveList.html" title="struct webrender::picture::PrimitiveList">Primitive<wbr>List</a></dt><dd>A list of primitive instances that are added to a picture
This ensures we can keep a list of primitives that
are pictures, for a fast initial traversal of the picture
tree without walking the instance list.</dd><dt><a class="struct" href="struct.RasterConfig.html" title="struct webrender::picture::RasterConfig">Raster<wbr>Config</a></dt><dt><a class="struct" href="struct.ScaleOffsetKey.html" title="struct webrender::picture::ScaleOffsetKey">Scale<wbr>Offset<wbr>Key</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A comparable scale-offset, that compares with epsilon checks.</dd><dt><a class="struct" href="struct.SliceId.html" title="struct webrender::picture::SliceId">SliceId</a></dt><dd>The key that identifies a tile cache instance. For now, itâ€™s simple the index of
the slice as it was created during scene building.</dd><dt><a class="struct" href="struct.SpatialNodeComparer.html" title="struct webrender::picture::SpatialNodeComparer">Spatial<wbr>Node<wbr>Comparer</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A helper for comparing spatial nodes between frames. The comparisons
are done by-value, so that if the shape of the spatial node tree
changes, invalidations arenâ€™t done simply due to the spatial node
index changing between display lists.</dd><dt><a class="struct" href="struct.SpatialNodeKey.html" title="struct webrender::picture::SpatialNodeKey">Spatial<wbr>Node<wbr>Key</a></dt><dd>A dependency for a transform is defined by the spatial node index + frame it was used</dd><dt><a class="struct" href="struct.SubSlice.html" title="struct webrender::picture::SubSlice">SubSlice</a></dt><dd>A SubSlice represents a potentially overlapping set of tiles within a picture cache. Most
picture cache instances will have only a single sub-slice. The exception to this is when
a picture cache has compositor surfaces, in which case sub slices are used to interleave
content under or order the compositor surface(s).</dd><dt><a class="struct" href="struct.SubSliceIndex.html" title="struct webrender::picture::SubSliceIndex">SubSlice<wbr>Index</a></dt><dd>Defines which sub-slice (effectively a z-index) a primitive exists on within
a picture cache instance.</dd><dt><a class="struct" href="struct.SurfaceAllocInfo.html" title="struct webrender::picture::SurfaceAllocInfo">Surface<wbr>Alloc<wbr>Info</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Information from <code>get_surface_rects</code> about the allocated size, UV sampling
parameters etc for an off-screen surface</dd><dt><a class="struct" href="struct.SurfaceIndex.html" title="struct webrender::picture::SurfaceIndex">Surface<wbr>Index</a></dt><dt><a class="struct" href="struct.SurfaceInfo.html" title="struct webrender::picture::SurfaceInfo">Surface<wbr>Info</a></dt><dd>Information about an offscreen surface. For now,
it contains information about the size and coordinate
system of the surface. In the future, it will contain
information about the contents of the surface, which
will allow surfaces to be cached / retained between
frames and display lists.</dd><dt><a class="struct" href="struct.Tile.html" title="struct webrender::picture::Tile">Tile</a></dt><dd>Information about a cached tile.</dd><dt><a class="struct" href="struct.TileCacheInstance.html" title="struct webrender::picture::TileCacheInstance">Tile<wbr>Cache<wbr>Instance</a></dt><dd>Represents a cache of tiles that make up a picture primitives.</dd><dt><a class="struct" href="struct.TileCacheParams.html" title="struct webrender::picture::TileCacheParams">Tile<wbr>Cache<wbr>Params</a></dt><dd>Information that is required to reuse or create a new tile cache. Created
during scene building and passed to the render backend / frame builder.</dd><dt><a class="struct" href="struct.TileCoordinate.html" title="struct webrender::picture::TileCoordinate">Tile<wbr>Coordinate</a></dt><dd>Unit for tile coordinates.</dd><dt><a class="struct" href="struct.TileDescriptor.html" title="struct webrender::picture::TileDescriptor">Tile<wbr>Descriptor</a></dt><dd>Uniquely describes the content of this tile, in a way that can be
(reasonably) efficiently hashed and compared.</dd><dt><a class="struct" href="struct.TileId.html" title="struct webrender::picture::TileId">TileId</a></dt><dd>A stable ID for a given tile, to help debugging. These are also used
as unique identifiers for tile surfaces when using a native compositor.</dd><dt><a class="struct" href="struct.TileKey.html" title="struct webrender::picture::TileKey">TileKey</a></dt><dd>Uniquely identifies a tile within a picture cache slice</dd><dt><a class="struct" href="struct.TileNode.html" title="struct webrender::picture::TileNode">Tile<wbr>Node</a></dt><dd>A node in the dirty rect tracking quadtree.</dd><dt><a class="struct" href="struct.TilePostUpdateContext.html" title="struct webrender::picture::TilePostUpdateContext">Tile<wbr>Post<wbr>Update<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.TilePostUpdateState.html" title="struct webrender::picture::TilePostUpdateState">Tile<wbr>Post<wbr>Update<wbr>State</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.TilePreUpdateContext.html" title="struct webrender::picture::TilePreUpdateContext">Tile<wbr>PreUpdate<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.TileUpdateDirtyContext.html" title="struct webrender::picture::TileUpdateDirtyContext">Tile<wbr>Update<wbr>Dirty<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.TileUpdateDirtyState.html" title="struct webrender::picture::TileUpdateDirtyState">Tile<wbr>Update<wbr>Dirty<wbr>State</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.BackdropKind.html" title="enum webrender::picture::BackdropKind">Backdrop<wbr>Kind</a></dt><dt><a class="enum" href="enum.Binding.html" title="enum webrender::picture::Binding">Binding</a></dt><dd>Information stored in a tile descriptor for a binding.</dd><dt><a class="enum" href="enum.CompareHelperResult.html" title="enum webrender::picture::CompareHelperResult">Compare<wbr>Helper<wbr>Result</a></dt><dd>Optional extra information returned by is_same when
logging is enabled.</dd><dt><a class="enum" href="enum.InvalidationReason.html" title="enum webrender::picture::InvalidationReason">Invalidation<wbr>Reason</a></dt><dd>Debugging information about why a tile was invalidated</dd><dt><a class="enum" href="enum.Picture3DContext.html" title="enum webrender::picture::Picture3DContext">Picture3D<wbr>Context</a></dt><dd>Enum value describing the place of a picture in a 3D context.</dd><dt><a class="enum" href="enum.PictureCompositeMode.html" title="enum webrender::picture::PictureCompositeMode">Picture<wbr>Composite<wbr>Mode</a></dt><dd>Specifies how this Picture should be composited
onto the target it belongs to.</dd><dt><a class="enum" href="enum.PrimitiveCompareResult.html" title="enum webrender::picture::PrimitiveCompareResult">Primitive<wbr>Compare<wbr>Result</a></dt><dd>The result of a primitive dependency comparison. Size is a u8
since this is a hot path in the code, and keeping the data small
is a performance win.</dd><dt><a class="enum" href="enum.PrimitiveDependency.html" title="enum webrender::picture::PrimitiveDependency">Primitive<wbr>Dependency</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="enum" href="enum.ResolvedSurfaceTexture.html" title="enum webrender::picture::ResolvedSurfaceTexture">Resolved<wbr>Surface<wbr>Texture</a></dt><dd>This is the same as a <code>SurfaceTextureDescriptor</code> but has been resolved
into a texture cache handle (if appropriate) that can be used by the
batching and compositing code in the renderer.</dd><dt><a class="enum" href="enum.SubpixelMode.html" title="enum webrender::picture::SubpixelMode">Subpixel<wbr>Mode</a></dt><dd>Specify whether a surface allows subpixel AA text rendering.</dd><dt><a class="enum" href="enum.SurfacePromotionFailure.html" title="enum webrender::picture::SurfacePromotionFailure">Surface<wbr>Promotion<wbr>Failure</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="enum" href="enum.SurfaceTextureDescriptor.html" title="enum webrender::picture::SurfaceTextureDescriptor">Surface<wbr>Texture<wbr>Descriptor</a></dt><dd>A descriptor for the kind of texture that a picture cache tile will
be drawn into.</dd><dt><a class="enum" href="enum.TileModification.html" title="enum webrender::picture::TileModification">Tile<wbr>Modification</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>The kind of modification that a tile wants to do</dd><dt><a class="enum" href="enum.TileNodeKind.html" title="enum webrender::picture::TileNodeKind">Tile<wbr>Node<wbr>Kind</a></dt><dd>Details for a node in a quadtree that tracks dirty rects for a tile.</dd><dt><a class="enum" href="enum.TileSurface.html" title="enum webrender::picture::TileSurface">Tile<wbr>Surface</a></dt><dd>The backing surface for this tile.</dd><dt><a class="enum" href="enum.TransformKey.html" title="enum webrender::picture::TransformKey">Transform<wbr>Key</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A comparable / hashable version of a coordinate space mapping. Used to determine
if a transform dependency for a tile has changed.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.MAX_BLUR_RADIUS.html" title="constant webrender::picture::MAX_BLUR_RADIUS">MAX_<wbr>BLUR_<wbr>RADIUS</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="constant" href="constant.MAX_COMPOSITOR_SURFACES.html" title="constant webrender::picture::MAX_COMPOSITOR_SURFACES">MAX_<wbr>COMPOSITOR_<wbr>SURFACES</a></dt><dd>The maximum number of compositor surfaces that are allowed per picture cache. This
is an arbitrary number that should be enough for common cases, but low enough to
prevent performance and memory usage drastically degrading in pathological cases.</dd><dt><a class="constant" href="constant.MAX_COMPOSITOR_SURFACES_SIZE.html" title="constant webrender::picture::MAX_COMPOSITOR_SURFACES_SIZE">MAX_<wbr>COMPOSITOR_<wbr>SURFACES_<wbr>SIZE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Maximum size of a compositor surface.</dd><dt><a class="constant" href="constant.MAX_SURFACE_SIZE.html" title="constant webrender::picture::MAX_SURFACE_SIZE">MAX_<wbr>SURFACE_<wbr>SIZE</a></dt><dd>The maximum size per axis of a surface, in DevicePixel coordinates.
Render tasks larger than this size are scaled down to fit, which may cause
some blurriness.</dd><dt><a class="constant" href="constant.TILE_SIZE_DEFAULT.html" title="constant webrender::picture::TILE_SIZE_DEFAULT">TILE_<wbr>SIZE_<wbr>DEFAULT</a></dt><dd>The size in device pixels of a normal cached tile.</dd><dt><a class="constant" href="constant.TILE_SIZE_SCROLLBAR_HORIZONTAL.html" title="constant webrender::picture::TILE_SIZE_SCROLLBAR_HORIZONTAL">TILE_<wbr>SIZE_<wbr>SCROLLBAR_<wbr>HORIZONTAL</a></dt><dd>The size in device pixels of a tile for horizontal scroll bars</dd><dt><a class="constant" href="constant.TILE_SIZE_SCROLLBAR_VERTICAL.html" title="constant webrender::picture::TILE_SIZE_SCROLLBAR_VERTICAL">TILE_<wbr>SIZE_<wbr>SCROLLBAR_<wbr>VERTICAL</a></dt><dd>The size in device pixels of a tile for vertical scroll bars</dd></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="static" href="static.NEXT_TILE_ID.html" title="static webrender::picture::NEXT_TILE_ID">NEXT_<wbr>TILE_<wbr>ID</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Used to get unique tile IDs, even when the tile cache is
destroyed between display lists / scenes.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.calculate_screen_uv.html" title="fn webrender::picture::calculate_screen_uv">calculate_<wbr>screen_<wbr>uv</a></dt><dt><a class="fn" href="fn.calculate_uv_rect_kind.html" title="fn webrender::picture::calculate_uv_rect_kind">calculate_<wbr>uv_<wbr>rect_<wbr>kind</a></dt><dt><a class="fn" href="fn.clamp.html" title="fn webrender::picture::clamp">clamp</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.clampf.html" title="fn webrender::picture::clampf">clampf</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.get_relative_scale_offset.html" title="fn webrender::picture::get_relative_scale_offset">get_<wbr>relative_<wbr>scale_<wbr>offset</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.get_surface_rects.html" title="fn webrender::picture::get_surface_rects">get_<wbr>surface_<wbr>rects</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.get_transform_key.html" title="fn webrender::picture::get_transform_key">get_<wbr>transform_<wbr>key</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.request_render_task.html" title="fn webrender::picture::request_render_task">request_<wbr>render_<wbr>task</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.ColorBinding.html" title="type webrender::picture::ColorBinding">Color<wbr>Binding</a></dt><dt><a class="type" href="type.ColorBindingInfo.html" title="type webrender::picture::ColorBindingInfo">Color<wbr>Binding<wbr>Info</a></dt><dt><a class="type" href="type.OpacityBinding.html" title="type webrender::picture::OpacityBinding">Opacity<wbr>Binding</a></dt><dt><a class="type" href="type.OpacityBindingInfo.html" title="type webrender::picture::OpacityBindingInfo">Opacity<wbr>Binding<wbr>Info</a></dt><dt><a class="type" href="type.TileOffset.html" title="type webrender::picture::TileOffset">Tile<wbr>Offset</a></dt><dt><a class="type" href="type.TileRect.html" title="type webrender::picture::TileRect">Tile<wbr>Rect</a></dt></dl></section></div></main></body></html>